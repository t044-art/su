<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•¸ç¨éŠæˆ²</title>
    <!-- è¼‰å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ä½¿ç”¨ Inter å­—é«” */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
        }
        /* æ•¸ç¨ç¶²æ ¼çš„è‡ªå®šç¾©æ¨£å¼ */
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            border: 4px solid #3b82f6; /* ä¸»è—è‰²é‚Šæ¡† */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .sudoku-cell {
            aspect-ratio: 1 / 1; /* ä¿æŒæ­£æ–¹å½¢ */
            border: 1px solid #d1d5db; /* æ·ºç°è‰²åˆ†éš”ç·š */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* è¼ƒå¤§çš„å­—é«”ä»¥åˆ©é»æ“Š */
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }

        /* ç²—é‚Šæ¡†ä¾†åˆ†éš” 3x3 å€å¡Š */
        .sudoku-cell:nth-child(9n+3),
        .sudoku-cell:nth-child(9n+6) {
            border-right-width: 3px;
            border-right-color: #9ca3af;
        }
        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom-width: 3px;
            border-bottom-color: #9ca3af;
        }
        .sudoku-grid > div:nth-child(27) ~ div > div:nth-child(9n+1) {
            border-top-width: 3px;
            border-top-color: #9ca3af;
        }
        .sudoku-grid > div:nth-child(54) ~ div > div:nth-child(9n+1) {
            border-top-width: 3px;
            border-top-color: #9ca3af;
        }

        /* è¼¸å…¥æ¡†çš„åŸºæœ¬æ¨£å¼ï¼Œç§»é™¤é»˜èªé‚Šæ¡†å’Œå¤–è§€ */
        .sudoku-input {
            width: 100%;
            height: 100%;
            text-align: center;
            border: none;
            outline: none;
            background-color: transparent;
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937; /* é è¨­è¼¸å…¥é¡è‰² */
            caret-color: #3b82f6; /* æ¸¸æ¨™é¡è‰² */
        }
        
        /* åˆå§‹æ•¸å­—çš„æ¨£å¼ */
        .fixed-cell {
            background-color: #e5e7eb; /* æ·ºç°è‰²èƒŒæ™¯ */
            color: #1f2937; /* æ·±è‰²æ–‡æœ¬ */
            font-weight: 800;
            cursor: default;
        }

        /* è¼¸å…¥ç‹€æ…‹æ¨£å¼ */
        .is-correct {
            color: #10b981; /* ç¶ è‰² */
        }
        .is-incorrect {
            color: #ef4444; /* ç´…è‰² */
            background-color: #fee2e2; /* æ·ºç´…èƒŒæ™¯ */
        }
        .is-highlighted {
            background-color: #bfdbfe; /* æ·ºè—è‰²é«˜äº® (é¸ä¸­çš„å–®å…ƒæ ¼) */
        }
        .is-related {
            background-color: #eff6ff; /* æ›´æ·ºçš„è—è‰²é«˜äº®ï¼ˆåŒä¸€è¡Œ/åˆ—/å€å¡Šï¼‰*/
        }
        .sudoku-input:focus {
            background-color: #dbeafe !important; /* ç„¦é»æ™‚æ·±è—è‰² */
        }
        /* éš±è—åŸç”Ÿæ•¸å­—è¼¸å…¥çš„ç®­é ­ */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }

        /* ä½¿ç¶²æ ¼åœ¨å°è¢å¹•ä¸Šä¿æŒç½®ä¸­ä¸”å¯¬åº¦åˆç† */
        #game-container {
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        /* --- æ•¸å­—é¢æ¿ (Keypad) æ¨£å¼ --- */
        .keypad-btn {
            width: 10%; 
            max-width: 60px;
            height: 60px;
            flex-grow: 1; /* åœ¨å°è¢å¹•ä¸Šå¹³å‡åˆ†é…å¯¬åº¦ */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 700;
            color: #1f2937;
            background-color: #e5e7eb;
            border-radius: 12px;
            transition: background-color 0.15s, transform 0.1s;
            cursor: pointer;
            border: none;
        }
        .keypad-btn:hover:not(:disabled) {
            background-color: #d1d5db;
            transform: translateY(-1px);
        }
        .keypad-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f3f4f6;
            color: #9ca3af;
            box-shadow: none;
        }
        /* å®Œæˆç‹€æ…‹æ¨£å¼ (æ•¸å­—å·²å¡«å…¥ 9 æ¬¡) */
        .is-completed {
            background-color: #10b981 !important; /* ç¶ è‰² */
            color: white !important;
            box-shadow: 0 4px 6px -1px rgba(16, 185, 129, 0.3), 0 2px 4px -2px rgba(16, 185, 129, 0.2);
        }
        .is-completed:hover:not(:disabled) {
            background-color: #059669 !important;
        }
        /* æ¸…é™¤æŒ‰éˆ•ç‰¹æ®Šæ¨£å¼ */
        .keypad-btn.clear-btn {
            width: 15%; /* çµ¦æ¸…é™¤æŒ‰éˆ•å¤šä¸€é»ç©ºé–“ */
            flex-grow: 1.5;
            background-color: #fca5a5;
            color: #7f1d1d;
        }
        .keypad-btn.clear-btn:hover {
            background-color: #f87171;
        }

    </style>
</head>
<body class="p-4 bg-gray-50 min-h-screen flex flex-col items-center">

    <div id="game-container" class="w-full">
        <h1 class="text-3xl font-extrabold text-center text-blue-600 mb-6 mt-4">æ•¸ç¨æŒ‘æˆ°</h1>

        <!-- é›£åº¦å’Œæ§åˆ¶å€å¡Š -->
        <div class="flex flex-col sm:flex-row justify-between items-center mb-6 p-4 bg-white rounded-xl shadow-lg">
            <div class="flex items-center space-x-3 mb-4 sm:mb-0">
                <label for="difficulty" class="text-gray-700 font-semibold whitespace-nowrap">é¸æ“‡é›£åº¦ï¼š</label>
                <select id="difficulty" class="p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
                    <!-- æ–°å¢æ¥µç°¡å–®é›£åº¦ (é è¨­é¸ä¸­) -->
                    <option value="super_easy" selected>æ¥µç°¡å–® (ç´„50å€‹)</option>
                    <option value="beginner">å…¥é–€ (ç´„40å€‹)</option>
                    <option value="easy">ç°¡å–® (ç´„35å€‹)</option>
                    <option value="medium">ä¸­ç­‰ (ç´„30å€‹)</option>
                    <option value="hard">å›°é›£ (ç´„25å€‹)</option>
                </select>
            </div>
            
            <button id="newGameBtn" class="w-full sm:w-auto px-6 py-3 bg-blue-600 text-white font-bold rounded-full shadow-md hover:bg-blue-700 transition duration-150 ease-in-out transform hover:scale-105">
                æ–°éŠæˆ²
            </button>
        </div>

        <!-- æ•¸ç¨ç¶²æ ¼ -->
        <div id="sudokuGrid" class="sudoku-grid w-full mb-6 rounded-xl overflow-hidden">
            <!-- ç¶²æ ¼å°‡ç”± JavaScript ç”¢ç”Ÿ -->
            <div class="w-full h-full flex items-center justify-center text-gray-500 text-lg">é»æ“Šã€Œæ–°éŠæˆ²ã€é–‹å§‹ï¼</div>
        </div>
        
        <!-- æª¢æŸ¥æŒ‰éˆ•å’Œè¨Šæ¯å€ -->
        <div class="flex flex-col items-center">
             <button id="checkBtn" class="w-full sm:w-48 px-6 py-3 bg-green-500 text-white font-bold rounded-full shadow-md hover:bg-green-600 transition duration-150 ease-in-out transform hover:scale-105 mb-4 disabled:bg-gray-400" disabled>
                æª¢æŸ¥
            </button>
            <div id="message" class="min-h-[2.5rem] text-center text-lg font-semibold text-gray-700 p-2 rounded-lg transition duration-300"></div>
        </div>

        <!-- æ•¸å­—è¼¸å…¥è¼”åŠ©éµç›¤ (æ•¸å­—å®Œæˆåˆ—) -->
        <div id="keypad" class="w-full p-4 mt-6 bg-white rounded-xl shadow-lg">
            <h3 class="text-md font-semibold text-gray-700 mb-3 text-center">æ•¸å­—é¢æ¿</h3>
            <div class="flex flex-wrap justify-between gap-2 sm:gap-4">
                <button data-value="1" class="keypad-btn">1</button>
                <button data-value="2" class="keypad-btn">2</button>
                <button data-value="3" class="keypad-btn">3</button>
                <button data-value="4" class="keypad-btn">4</button>
                <button data-value="5" class="keypad-btn">5</button>
                <button data-value="6" class="keypad-btn">6</button>
                <button data-value="7" class="keypad-btn">7</button>
                <button data-value="8" class="keypad-btn">8</button>
                <button data-value="9" class="keypad-btn">9</button>
                <button data-value="0" class="keypad-btn clear-btn text-red-800 hover:text-red-900">æ¸…é™¤</button>
            </div>
        </div>

    </div>

    <script>
        // å…¨å±€è®Šé‡
        let solution = []; // å®Œæ•´çš„æ•¸ç¨è§£
        let puzzle = [];   // åˆå§‹é¡Œç›® (å›ºå®šæ•¸å­—ç‚ºé0)
        let currentBoard = []; // ç©å®¶ç•¶å‰çš„è¼¸å…¥ç‹€æ…‹
        let isGameActive = false;
        let activeCell = null; // ç•¶å‰èšç„¦çš„è¼¸å…¥æ¡†
        const gridSize = 9;

        // --- é–’ç½®è¿½è¹¤ ---
        let inactivityTimer = null;
        const INACTIVITY_LIMIT = 60000; // 60 ç§’ (1 åˆ†é˜)
        // --- é–’ç½®è¿½è¹¤ (çµæŸ) ---

        // --- DOM å…ƒç´ ç²å– ---
        const sudokuGridEl = document.getElementById('sudokuGrid');
        const newGameBtn = document.getElementById('newGameBtn');
        const checkBtn = document.getElementById('checkBtn');
        const messageEl = document.getElementById('message');
        const difficultySelect = document.getElementById('difficulty');
        const keypadEl = document.getElementById('keypad');

        // --- æ•¸ç¨æ ¸å¿ƒé‚è¼¯ (ä¸è®Š) ---

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function isValid(board, row, col, num) {
            for (let c = 0; c < gridSize; c++) {
                if (board[row][c] === num) return false;
            }
            for (let r = 0; r < gridSize; r++) {
                if (board[r][col] === num) return false;
            }
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[startRow + r][startCol + c] === num) return false;
                }
            }
            return true;
        }

        function generateSolution(board) {
            let row = -1;
            let col = -1;
            let isEmpty = true;

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (board[r][c] === 0) {
                        row = r;
                        col = c;
                        isEmpty = false;
                        break;
                    }
                }
                if (!isEmpty) break;
            }

            if (isEmpty) {
                return true;
            }

            let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            shuffleArray(numbers); 

            for (const num of numbers) {
                if (isValid(board, row, col, num)) {
                    board[row][col] = num;
                    if (generateSolution(board)) {
                        return true;
                    }
                    board[row][col] = 0;
                }
            }

            return false;
        }

        function createPuzzle(fullSolution, difficulty) {
            let cellsToRemove;
            switch (difficulty) {
                case 'super_easy': // <-- æ–°å¢çš„æ¥µç°¡å–®é›£åº¦ (ç•™ä¸‹ç´„ 50 å€‹ç·šç´¢)
                    cellsToRemove = 31; 
                    break;
                case 'beginner': 
                    cellsToRemove = 41; // ç•™ä¸‹ 40 å€‹ç·šç´¢
                    break;
                case 'easy':
                    cellsToRemove = 46; 
                    break;
                case 'medium':
                    cellsToRemove = 51; 
                    break;
                case 'hard':
                    cellsToRemove = 56; 
                    break;
                default:
                    cellsToRemove = 51;
            }

            const puzzleBoard = fullSolution.map(row => [...row]);
            let attempts = cellsToRemove;

            while (attempts > 0) {
                let row = Math.floor(Math.random() * gridSize);
                let col = Math.floor(Math.random() * gridSize);
                
                if (puzzleBoard[row][col] === 0) continue;

                puzzleBoard[row][col] = 0; 
                attempts--;
            }

            return puzzleBoard;
        }

        // --- æ•¸å­—å®Œæˆç‹€æ…‹é‚è¼¯ ---

        /**
         * è¨ˆç®—ç•¶å‰æ£‹ç›¤ä¸Šæ¯å€‹æ•¸å­— (1-9) çš„å‡ºç¾æ¬¡æ•¸ã€‚
         * @returns {Object} åŒ…å« {1: count, 2: count, ...} çš„ç‰©ä»¶
         */
        function countNumberOccurrences() {
            const counts = {};
            for (let i = 1; i <= 9; i++) {
                counts[i] = 0;
            }

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const value = currentBoard[r][c];
                    if (value >= 1 && value <= 9) {
                        counts[value]++;
                    }
                }
            }
            return counts;
        }

        /**
         * æ ¹æ“šæ•¸å­—çš„å‡ºç¾æ¬¡æ•¸æ›´æ–°æ•¸å­—é¢æ¿çš„è¦–è¦ºç‹€æ…‹ã€‚
         */
        function updateKeypadStatus() {
            const counts = countNumberOccurrences();
            
            // ç”±æ–¼æˆ‘å€‘åªé—œå¿ƒå®Œæˆçš„æ•¸å­—ï¼Œåªæª¢æŸ¥ 1 åˆ° 9
            for (let num = 1; num <= 9; num++) {
                const btn = keypadEl.querySelector(`.keypad-btn[data-value="${num}"]`);
                if (!btn) continue;

                btn.classList.remove('is-completed');
                
                // æ•¸ç¨çš„æ¯å€‹æ•¸å­—åªèƒ½å‡ºç¾ 9 æ¬¡
                if (counts[num] === 9) {
                    btn.classList.add('is-completed');
                }
            }
        }

        // --- é–’ç½®è¨ˆæ™‚å™¨é‚è¼¯ ---

        /**
         * é¡¯ç¤ºé¼“å‹µæç¤ºè¨Šæ¯ (å¦‚æœéŠæˆ²æ­£åœ¨é€²è¡Œ)ã€‚
         */
        function triggerHint() {
            if (isGameActive) {
                // æª¢æŸ¥æ˜¯å¦é‚„æœ‰ç©ºæ ¼ï¼Œé¿å…éŠæˆ²çµæŸå¾Œè§¸ç™¼
                const hasEmptyCells = currentBoard.some(row => row.includes(0));
                
                if (hasEmptyCells) {
                    messageEl.textContent = 'ğŸ¤” åœæ»¯ä¸å‰å—ï¼Ÿè©¦è‘—å°ˆæ³¨æ–¼ä¸€å€‹ 3x3 çš„å€å¡Šå§ï¼';
                    messageEl.classList.add('bg-yellow-100', 'text-yellow-800');
                    // é‡è¨­è¨ˆæ™‚å™¨ï¼Œé¿å…ç«‹å³å†æ¬¡å½ˆå‡º
                    resetInactivityTimer();
                } else {
                    // å¦‚æœæ²’æœ‰ç©ºæ ¼äº†ï¼Œå‰‡ä¸æç¤º
                }
            }
        }

        /**
         * é‡è¨­é–’ç½®è¨ˆæ™‚å™¨ã€‚
         */
        function resetInactivityTimer() {
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            if (isGameActive) {
                // åƒ…åœ¨éŠæˆ²æ´»èºæ™‚æ‰è¨­ç½®æ–°çš„è¨ˆæ™‚å™¨
                inactivityTimer = setTimeout(triggerHint, INACTIVITY_LIMIT);
            }
        }
        // --- é–’ç½®è¨ˆæ™‚å™¨é‚è¼¯ (çµæŸ) ---


        // --- éŠæˆ²åˆå§‹åŒ–å’Œæ§åˆ¶ ---

        async function startNewGame() {
            messageEl.textContent = 'ç­‰ç­‰... æ­£åœ¨ç”¢ç”Ÿæ–°çš„æ•¸ç¨...';
            messageEl.className = 'min-h-[2.5rem] text-center text-lg font-semibold text-gray-700 p-2 rounded-lg transition duration-300';
            isGameActive = false;
            checkBtn.disabled = true;
            newGameBtn.disabled = true;

            const emptyBoard = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            await new Promise(resolve => setTimeout(resolve, 50)); 
            
            try {
                if (generateSolution(emptyBoard)) {
                    solution = emptyBoard;
                    const difficulty = difficultySelect.value;
                    puzzle = createPuzzle(solution, difficulty);
                    
                    currentBoard = puzzle.map(row => [...row]);

                    renderGrid(puzzle);
                    updateKeypadStatus(); // åˆå§‹åŒ–æ•¸å­—é¢æ¿ç‹€æ…‹

                    isGameActive = true;
                    checkBtn.disabled = false;
                    newGameBtn.disabled = false;
                    messageEl.textContent = 'æ–°éŠæˆ²å·²å•Ÿå‹•ï¼';

                    resetInactivityTimer(); // åœ¨éŠæˆ²é–‹å§‹æ™‚å•Ÿå‹•è¨ˆæ™‚å™¨
                } else {
                    messageEl.textContent = 'ç”¢ç”Ÿæ•¸ç¨å¤±æ•—ï¼Œè«‹å†è©¦ä¸€æ¬¡ã€‚';
                    newGameBtn.disabled = false;
                }
            } catch (error) {
                console.error("ç”Ÿæˆæ•¸ç¨æ™‚ç™¼ç”ŸéŒ¯èª¤:", error);
                messageEl.textContent = 'ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥æ§åˆ¶å°ã€‚';
                newGameBtn.disabled = false;
            }
        }

        function renderGrid(board) {
            sudokuGridEl.innerHTML = '';
            sudokuGridEl.className = 'sudoku-grid w-full mb-6 rounded-xl overflow-hidden'; 

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'sudoku-cell';
                    cellDiv.dataset.row = r;
                    cellDiv.dataset.col = c;
                    
                    const value = board[r][c];

                    if (value !== 0) {
                        cellDiv.textContent = value;
                        cellDiv.classList.add('fixed-cell');
                    } else {
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.className = 'sudoku-input';
                        input.maxLength = 1;
                        input.min = 1;
                        input.max = 9;
                        input.inputMode = 'numeric'; 
                        input.dataset.row = r;
                        input.dataset.col = c;
                        input.value = currentBoard[r][c] === 0 ? '' : currentBoard[r][c];

                        input.addEventListener('input', handleInput);
                        input.addEventListener('focus', handleFocus);
                        input.addEventListener('blur', handleBlur);

                        cellDiv.appendChild(input);
                    }
                    sudokuGridEl.appendChild(cellDiv);
                }
            }
        }

        // --- äº‹ä»¶è™•ç†å™¨ ---

        function handleInput(event) {
            const inputEl = event.target;
            let value = parseInt(inputEl.value.replace(/[^1-9]/g, ''));

            if (inputEl.value.length > 1) {
                value = parseInt(inputEl.value.slice(0, 1));
            }

            if (isNaN(value) || value === 0) {
                value = 0;
                inputEl.value = '';
            } else {
                inputEl.value = value;
            }
            
            const r = parseInt(inputEl.dataset.row);
            const c = parseInt(inputEl.dataset.col);

            currentBoard[r][c] = value;

            checkCellVisual(inputEl, r, c, value);
            updateKeypadStatus();
            
            resetInactivityTimer(); // <--- é‡è¨­è¨ˆæ™‚å™¨

            if (currentBoard.every(row => row.every(val => val !== 0))) {
                checkFullSolution(true); 
            }
        }
        
        // ç§»é™¤è™›æ“¬éµç›¤çš„é¡¯ç¤º/éš±è—é‚è¼¯ï¼Œå› ç‚ºæ•¸å­—é¢æ¿ç¾åœ¨æ˜¯å¸¸é§çš„
        function handleFocus(event) {
            const inputEl = event.target;
            activeCell = inputEl;
            const r = parseInt(inputEl.dataset.row);
            const c = parseInt(inputEl.dataset.col);
            
            highlightRelatedCells(r, c);
            resetInactivityTimer(); // <--- é‡è¨­è¨ˆæ™‚å™¨
        }

        function handleBlur(event) {
             // å»¶é²æ¸…é™¤é«˜äº®ï¼Œé¿å…å½±éŸ¿ keypad é»æ“Š
            setTimeout(() => {
                 // åƒ…åœ¨ç„¦é»ä¸åœ¨ä»»ä½•è¼¸å…¥æ¡†æˆ–æ•¸å­—é¢æ¿ä¸Šæ™‚æ‰æ¸…é™¤é«˜äº®
                 if (!sudokuGridEl.contains(document.activeElement) && !keypadEl.contains(document.activeElement)) {
                    clearHighlights();
                    activeCell = null;
                 }
            }, 10);
        }

        /**
         * è™•ç†æ•¸å­—é¢æ¿æŒ‰éˆ•é»æ“Š
         */
        function handleKeypadClick(event) {
            const btn = event.target.closest('.keypad-btn');
            if (!btn || !activeCell) return;

            const value = btn.dataset.value;
            let inputEvent = new Event('input', { bubbles: true });

            if (value === '0') {
                // æ¸…é™¤
                activeCell.value = '';
            } else {
                // æ•¸å­—è¼¸å…¥
                activeCell.value = value;
            }
            activeCell.dispatchEvent(inputEvent); 
            
            // ä¿æŒç„¦é»åœ¨è¼¸å…¥æ¡†ä¸Š
            activeCell.focus();
            
            resetInactivityTimer(); // <--- é‡è¨­è¨ˆæ™‚å™¨
        }

        function checkCellVisual(inputEl, r, c, value) {
            const parentCell = inputEl.parentElement;
            parentCell.classList.remove('is-correct', 'is-incorrect', 'bg-fee2e2');

            if (value === 0) {
                return;
            }

            if (value === solution[r][c]) {
                parentCell.classList.add('is-correct');
            } else {
                parentCell.classList.add('is-incorrect');
            }
        }
        
        function highlightRelatedCells(r, c) {
            clearHighlights();

            const allCells = sudokuGridEl.querySelectorAll('.sudoku-cell');

            for (const cell of allCells) {
                const cellR = parseInt(cell.dataset.row);
                const cellC = parseInt(cell.dataset.col);
                
                const isSelectedCell = (cellR === r && cellC === c);
                const isSameRowOrCol = (cellR === r || cellC === c);
                const isSameBlock = (Math.floor(cellR / 3) === Math.floor(r / 3) && Math.floor(cellC / 3) === Math.floor(c / 3));

                if (isSelectedCell) {
                    cell.classList.add('is-highlighted');
                } else if (isSameRowOrCol || isSameBlock) {
                    cell.classList.add('is-related');
                }
            }
        }

        function clearHighlights() {
            sudokuGridEl.querySelectorAll('.is-highlighted, .is-related').forEach(cell => {
                cell.classList.remove('is-highlighted', 'is-related');
            });
        }


        function checkFullSolution(isAutoCheck = false) {
            if (!isGameActive) return;

            let isFinished = true;
            let isAllCorrect = true;

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const value = currentBoard[r][c];
                    
                    if (value === 0) {
                        isFinished = false;
                        if (!isAutoCheck) { 
                             const inputEl = sudokuGridEl.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
                             if (inputEl) {
                                inputEl.parentElement.classList.remove('is-correct', 'is-incorrect');
                             }
                        }
                    } else {
                        if (value !== solution[r][c]) {
                            isAllCorrect = false;
                        }
                        
                        if (!isAutoCheck) {
                             const inputEl = sudokuGridEl.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
                             if (inputEl) {
                                checkCellVisual(inputEl, r, c, value);
                             }
                        }
                    }
                }
            }

            messageEl.classList.remove('bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-blue-100', 'text-blue-800', 'bg-yellow-100', 'text-yellow-800');

            if (isFinished && isAllCorrect) {
                isGameActive = false;
                checkBtn.disabled = true;
                messageEl.textContent = 'â­â­ æ­å–œï¼ä½ å®Œæˆäº†æ•¸ç¨ï¼ â­â­';
                messageEl.classList.add('bg-green-100', 'text-green-800');
                sudokuGridEl.querySelectorAll('.sudoku-cell:not(.fixed-cell)').forEach(cell => {
                    cell.classList.add('is-correct');
                    cell.classList.remove('is-incorrect');
                });
                
            } else if (isFinished && !isAllCorrect) {
                 messageEl.textContent = 'ç¹¼çºŒåŠ æ²¹ï¼Œä½ å¡«æ»¿äº†æ‰€æœ‰æ ¼å­ï¼Œä½†æœ‰äº›æ•¸å­—ä¸å°å–”ï¼';
                 messageEl.classList.add('bg-red-100', 'text-red-800');
            }
            else if (!isAutoCheck && !isAllCorrect) {
                 messageEl.textContent = 'è«‹çœ‹ç´…è‰²æ¨™è¨˜è™•ï¼Œæœ‰äº›æ•¸å­—ä¸å°å–”ï¼';
                 messageEl.classList.add('bg-red-100', 'text-red-800');
            }
             else if (!isFinished && !isAutoCheck) {
                messageEl.textContent = 'ç¹¼çºŒåŠ æ²¹ï¼Œä½ é‚„æ²’æœ‰å¡«æ»¿æ‰€æœ‰æ ¼å­ã€‚';
                messageEl.classList.add('bg-blue-100', 'text-blue-800');
            }
        }


        // --- å•Ÿå‹•èˆ‡ç¶å®š ---
        
        document.addEventListener('DOMContentLoaded', () => {
            sudokuGridEl.innerHTML = '<div class="col-span-9 p-8 text-center text-lg text-gray-500">é»æ“Šã€Œæ–°éŠæˆ²ã€æŒ‰éˆ•é–‹å§‹ä½ çš„æ•¸ç¨æŒ‘æˆ°ï¼</div>';

            newGameBtn.addEventListener('click', startNewGame);
            checkBtn.addEventListener('click', () => checkFullSolution(false));
            keypadEl.addEventListener('click', handleKeypadClick);
            
            // è™•ç†éµç›¤è¼¸å…¥ (æ¡Œé¢ç‰ˆ)
            document.addEventListener('keydown', (event) => {
                if (activeCell) {
                    const key = event.key;
                    // åªè™•ç† 1-9 å’Œæ¸…é™¤éµ
                    if ((key >= '1' && key <= '9') || key === 'Backspace' || key === 'Delete') {
                        activeCell.value = (key === 'Backspace' || key === 'Delete') ? '' : key;
                        let inputEvent = new Event('input', { bubbles: true });
                        activeCell.dispatchEvent(inputEvent);
                    }
                }
            });

             // åˆå§‹å‘¼å«ï¼Œç¢ºä¿æ•¸å­—é¢æ¿åœ¨é–‹å§‹å‰æ˜¯ä¹¾æ·¨çš„
             updateKeypadStatus();
        });

    </script>
</body>
</html>
